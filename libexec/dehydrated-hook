#!/bin/bash
# shellcheck disable=2034,1091
set -euo pipefail

# shellcheck source=share/common.sh
. "$LETSENCRYPT_SHAREDIR/common.sh"

deploy_challenge() {
    local DOMAIN="${1}" TOKEN_FILENAME="${2}" TOKEN_VALUE="${3}"
    local route_name; route_name="$(well_known_route_name "$DOMAIN")"

    if route_exists "$route_name"; then
        log "Deleting well-known route."
        delete_well_known_route "$DOMAIN"
    fi

    log "Adding well-known route."
    add_well_known_route "$DOMAIN"

    # sleep for max 50s waiting for admitted route
    for ((i=50; i > 0; i--)); do
        sleep 2s
        if route_is_valid "$route_name"; then
            exit 0
        fi
    done

    log "Route $route_name not yet admitted."
    exit 1
}

clean_challenge() {
    local DOMAIN="${1}" TOKEN_FILENAME="${2}" TOKEN_VALUE="${3}"

    log "Deleting well-known route."
    delete_well_known_route "$DOMAIN"
}

deploy_cert() {
    local DOMAIN="${1}" KEYFILE="${2}" CERTFILE="${3}"
    local FULLCHAINFILE="${4}" CHAINFILE="${5}" TIMESTAMP="${6}"

    cp "$KEYFILE" "$(keyfile "$DOMAIN")"
    cp "$CERTFILE" "$(certfile "$DOMAIN")"
    cp "$FULLCHAINFILE" "$(fullchainfile "$DOMAIN")"

    log "Defer deploying certificate for routes."
}

unchanged_cert() {
    local DOMAIN="${1}" KEYFILE="${2}" CERTFILE="${3}"
    local FULLCHAINFILE="${4}" CHAINFILE="${5}"

    log "Certificate for $DOMAIN unchanged."
}

exit_hook() {
    log "Running exit_hook"
}

request_failure() {
    local STATUSCODE="${1}" REASON="${2}" REQTYPE="${3}"
    log "request_failure  statuscode=$STATUSCODE reason=$REASON reqtype=$REQTYPE"
}

invalid_challenge() {
    local DOMAIN="${1}" RESPONSE="${2}"
    log "invalid_challenge: domain=${DOMAIN}:"
    log "$RESPONSE"
}

HANDLER="$1"; shift
# check if $HANDLER is a defined function
if compgen -A function | grep -q "^${HANDLER}\$"; then
    $HANDLER "$@"
else
    log "Hander not defined: $HANDLER"
fi
